<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Mp4FromDashWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debugAndroidTest</a> &gt; <a href="index.source.html" class="el_package">org.schabi.newpipe.streams</a> &gt; <span class="el_source">Mp4FromDashWriter.java</span></div><h1>Mp4FromDashWriter.java</h1><pre class="source lang-java linenums">package org.schabi.newpipe.streams;

import org.schabi.newpipe.streams.Mp4DashReader.Hdlr;
import org.schabi.newpipe.streams.Mp4DashReader.Mdia;
import org.schabi.newpipe.streams.Mp4DashReader.Mp4DashChunk;
import org.schabi.newpipe.streams.Mp4DashReader.Mp4DashSample;
import org.schabi.newpipe.streams.Mp4DashReader.Mp4Track;
import org.schabi.newpipe.streams.Mp4DashReader.TrunEntry;
import org.schabi.newpipe.streams.io.SharpStream;

import java.io.IOException;
import java.nio.ByteBuffer;

/**
 * @author kapodamy
 */
public class Mp4FromDashWriter {

    private final static int EPOCH_OFFSET = 2082844800;
    private final static short DEFAULT_TIMESCALE = 1000;
    private final static byte SAMPLES_PER_CHUNK_INIT = 2;
    private final static byte SAMPLES_PER_CHUNK = 6;// ffmpeg uses 2, basic uses 1 (with 60fps uses 21 or 22). NewPipe will use 6
    private final static long THRESHOLD_FOR_CO64 = 0xFFFEFFFFL;// near 3.999 GiB
    private final static int THRESHOLD_MOOV_LENGTH = (256 * 1024) + (2048 * 1024); // 2.2 MiB enough for: 1080p 60fps 00h35m00s

    private final long time;

    private ByteBuffer auxBuffer;
    private SharpStream outStream;

<span class="nc" id="L31">    private long lastWriteOffset = -1;</span>
    private long writeOffset;

<span class="nc" id="L34">    private boolean moovSimulation = true;</span>

<span class="nc" id="L36">    private boolean done = false;</span>
<span class="nc" id="L37">    private boolean parsed = false;</span>

    private Mp4Track[] tracks;
    private SharpStream[] sourceTracks;

    private Mp4DashReader[] readers;
    private Mp4DashChunk[] readersChunks;

<span class="nc" id="L45">    private int overrideMainBrand = 0x00;</span>

<span class="nc" id="L47">    public Mp4FromDashWriter(SharpStream... sources) throws IOException {</span>
<span class="nc bnc" id="L48" title="All 2 branches missed.">        for (SharpStream src : sources) {</span>
<span class="nc bnc" id="L49" title="All 4 branches missed.">            if (!src.canRewind() &amp;&amp; !src.canRead()) {</span>
<span class="nc" id="L50">                throw new IOException(&quot;All sources must be readable and allow rewind&quot;);</span>
            }
        }

<span class="nc" id="L54">        sourceTracks = sources;</span>
<span class="nc" id="L55">        readers = new Mp4DashReader[sourceTracks.length];</span>
<span class="nc" id="L56">        readersChunks = new Mp4DashChunk[readers.length];</span>
<span class="nc" id="L57">        time = (System.currentTimeMillis() / 1000L) + EPOCH_OFFSET;</span>
<span class="nc" id="L58">    }</span>

    public Mp4Track[] getTracksFromSource(int sourceIndex) throws IllegalStateException {
<span class="nc bnc" id="L61" title="All 2 branches missed.">        if (!parsed) {</span>
<span class="nc" id="L62">            throw new IllegalStateException(&quot;All sources must be parsed first&quot;);</span>
        }

<span class="nc" id="L65">        return readers[sourceIndex].getAvailableTracks();</span>
    }

    public void parseSources() throws IOException, IllegalStateException {
<span class="nc bnc" id="L69" title="All 2 branches missed.">        if (done) {</span>
<span class="nc" id="L70">            throw new IllegalStateException(&quot;already done&quot;);</span>
        }
<span class="nc bnc" id="L72" title="All 2 branches missed.">        if (parsed) {</span>
<span class="nc" id="L73">            throw new IllegalStateException(&quot;already parsed&quot;);</span>
        }

        try {
<span class="nc bnc" id="L77" title="All 2 branches missed.">            for (int i = 0; i &lt; readers.length; i++) {</span>
<span class="nc" id="L78">                readers[i] = new Mp4DashReader(sourceTracks[i]);</span>
<span class="nc" id="L79">                readers[i].parse();</span>
            }

        } finally {
<span class="nc" id="L83">            parsed = true;</span>
<span class="nc" id="L84">        }</span>
<span class="nc" id="L85">    }</span>

    public void selectTracks(int... trackIndex) throws IOException {
<span class="nc bnc" id="L88" title="All 2 branches missed.">        if (done) {</span>
<span class="nc" id="L89">            throw new IOException(&quot;already done&quot;);</span>
        }
<span class="nc bnc" id="L91" title="All 2 branches missed.">        if (tracks != null) {</span>
<span class="nc" id="L92">            throw new IOException(&quot;tracks already selected&quot;);</span>
        }

        try {
<span class="nc" id="L96">            tracks = new Mp4Track[readers.length];</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">            for (int i = 0; i &lt; readers.length; i++) {</span>
<span class="nc" id="L98">                tracks[i] = readers[i].selectTrack(trackIndex[i]);</span>
            }
        } finally {
<span class="nc" id="L101">            parsed = true;</span>
<span class="nc" id="L102">        }</span>
<span class="nc" id="L103">    }</span>

    public void setMainBrand(int brandId) {
<span class="nc" id="L106">        overrideMainBrand = brandId;</span>
<span class="nc" id="L107">    }</span>

    public boolean isDone() {
<span class="nc" id="L110">        return done;</span>
    }

    public boolean isParsed() {
<span class="nc" id="L114">        return parsed;</span>
    }

    public void close() throws IOException {
<span class="nc" id="L118">        done = true;</span>
<span class="nc" id="L119">        parsed = true;</span>

<span class="nc bnc" id="L121" title="All 2 branches missed.">        for (SharpStream src : sourceTracks) {</span>
<span class="nc" id="L122">            src.close();</span>
        }

<span class="nc" id="L125">        tracks = null;</span>
<span class="nc" id="L126">        sourceTracks = null;</span>

<span class="nc" id="L128">        readers = null;</span>
<span class="nc" id="L129">        readersChunks = null;</span>

<span class="nc" id="L131">        auxBuffer = null;</span>
<span class="nc" id="L132">        outStream = null;</span>
<span class="nc" id="L133">    }</span>

    public void build(SharpStream output) throws IOException {
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (done) {</span>
<span class="nc" id="L137">            throw new RuntimeException(&quot;already done&quot;);</span>
        }
<span class="nc bnc" id="L139" title="All 2 branches missed.">        if (!output.canWrite()) {</span>
<span class="nc" id="L140">            throw new IOException(&quot;the provided output is not writable&quot;);</span>
        }

        //
        // WARNING: the muxer requires at least 8 samples of every track
        //          not allowed for very short tracks (less than 0.5 seconds)
        //
<span class="nc" id="L147">        outStream = output;</span>
<span class="nc" id="L148">        int read = 8;// mdat box header size</span>
<span class="nc" id="L149">        long totalSampleSize = 0;</span>
<span class="nc" id="L150">        int[] sampleExtra = new int[readers.length];</span>
<span class="nc" id="L151">        int[] defaultMediaTime = new int[readers.length];</span>
<span class="nc" id="L152">        int[] defaultSampleDuration = new int[readers.length];</span>
<span class="nc" id="L153">        int[] sampleCount = new int[readers.length];</span>

<span class="nc" id="L155">        TablesInfo[] tablesInfo = new TablesInfo[tracks.length];</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">        for (int i = 0; i &lt; tablesInfo.length; i++) {</span>
<span class="nc" id="L157">            tablesInfo[i] = new TablesInfo();</span>
        }

        //&lt;editor-fold defaultstate=&quot;expanded&quot; desc=&quot;calculate stbl sample tables size and required moov values&quot;&gt;
<span class="nc bnc" id="L161" title="All 2 branches missed.">        for (int i = 0; i &lt; readers.length; i++) {</span>
<span class="nc" id="L162">            int samplesSize = 0;</span>
<span class="nc" id="L163">            int sampleSizeChanges = 0;</span>
<span class="nc" id="L164">            int compositionOffsetLast = -1;</span>

            Mp4DashChunk chunk;
<span class="nc bnc" id="L167" title="All 2 branches missed.">            while ((chunk = readers[i].getNextChunk(true)) != null) {</span>

<span class="nc bnc" id="L169" title="All 4 branches missed.">                if (defaultMediaTime[i] &lt; 1 &amp;&amp; chunk.moof.traf.tfhd.defaultSampleDuration &gt; 0) {</span>
<span class="nc" id="L170">                    defaultMediaTime[i] = chunk.moof.traf.tfhd.defaultSampleDuration;</span>
                }

<span class="nc" id="L173">                read += chunk.moof.traf.trun.chunkSize;</span>
<span class="nc" id="L174">                sampleExtra[i] += chunk.moof.traf.trun.chunkDuration;// calculate track duration</span>

                TrunEntry info;
<span class="nc bnc" id="L177" title="All 2 branches missed.">                while ((info = chunk.getNextSampleInfo()) != null) {</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">                    if (info.isKeyframe) {</span>
<span class="nc" id="L179">                        tablesInfo[i].stss++;</span>
                    }

<span class="nc bnc" id="L182" title="All 2 branches missed.">                    if (info.sampleDuration &gt; defaultSampleDuration[i]) {</span>
<span class="nc" id="L183">                        defaultSampleDuration[i] = info.sampleDuration;</span>
                    }

<span class="nc" id="L186">                    tablesInfo[i].stsz++;</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">                    if (samplesSize != info.sampleSize) {</span>
<span class="nc" id="L188">                        samplesSize = info.sampleSize;</span>
<span class="nc" id="L189">                        sampleSizeChanges++;</span>
                    }

<span class="nc bnc" id="L192" title="All 2 branches missed.">                    if (info.hasCompositionTimeOffset) {</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">                        if (info.sampleCompositionTimeOffset != compositionOffsetLast) {</span>
<span class="nc" id="L194">                            tablesInfo[i].ctts++;</span>
<span class="nc" id="L195">                            compositionOffsetLast = info.sampleCompositionTimeOffset;</span>
                        }
                    }

<span class="nc" id="L199">                    totalSampleSize += info.sampleSize;</span>
                }
<span class="nc" id="L201">            }</span>

<span class="nc bnc" id="L203" title="All 2 branches missed.">            if (defaultMediaTime[i] &lt; 1) {</span>
<span class="nc" id="L204">                defaultMediaTime[i] = defaultSampleDuration[i];</span>
            }

<span class="nc" id="L207">            readers[i].rewind();</span>

<span class="nc" id="L209">            int tmp = tablesInfo[i].stsz - SAMPLES_PER_CHUNK_INIT;</span>
<span class="nc" id="L210">            tablesInfo[i].stco = (tmp / SAMPLES_PER_CHUNK) + 1;// +1 for samples in first chunk</span>

<span class="nc" id="L212">            tmp = tmp % SAMPLES_PER_CHUNK;</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">            if (tmp == 0) {</span>
<span class="nc" id="L214">                tablesInfo[i].stsc = 2;// first chunk (init) and succesive chunks</span>
<span class="nc" id="L215">                tablesInfo[i].stsc_bEntries = new int[]{</span>
                        1, SAMPLES_PER_CHUNK_INIT, 1,
                        2, SAMPLES_PER_CHUNK, 1
                };
            } else {
<span class="nc" id="L220">                tablesInfo[i].stsc = 3;// first chunk (init) and succesive chunks and remain chunk</span>
<span class="nc" id="L221">                tablesInfo[i].stsc_bEntries = new int[]{</span>
                        1, SAMPLES_PER_CHUNK_INIT, 1,
                        2, SAMPLES_PER_CHUNK, 1,
                        tablesInfo[i].stco + 1, tmp, 1
                };
<span class="nc" id="L226">                tablesInfo[i].stco++;</span>
            }

<span class="nc" id="L229">            sampleCount[i] = tablesInfo[i].stsz;</span>

<span class="nc bnc" id="L231" title="All 2 branches missed.">            if (sampleSizeChanges == 1) {</span>
<span class="nc" id="L232">                tablesInfo[i].stsz = 0;</span>
<span class="nc" id="L233">                tablesInfo[i].stsz_default = samplesSize;</span>
            } else {
<span class="nc" id="L235">                tablesInfo[i].stsz_default = 0;</span>
            }

<span class="nc bnc" id="L238" title="All 2 branches missed.">            if (tablesInfo[i].stss == tablesInfo[i].stsz) {</span>
<span class="nc" id="L239">                tablesInfo[i].stss = -1;// for audio tracks (all samples are keyframes)</span>
            }

            // ensure track duration
<span class="nc bnc" id="L243" title="All 2 branches missed.">            if (tracks[i].trak.tkhd.duration &lt; 1) {</span>
<span class="nc" id="L244">                tracks[i].trak.tkhd.duration = sampleExtra[i];// this never should happen</span>
            }
        }
        //&lt;/editor-fold&gt;

<span class="nc bnc" id="L249" title="All 2 branches missed.">        boolean is64 = read &gt; THRESHOLD_FOR_CO64;</span>

        // calculate the moov size;
<span class="nc" id="L252">        int auxSize = make_moov(defaultMediaTime, tablesInfo, is64);</span>

<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (auxSize &lt; THRESHOLD_MOOV_LENGTH) {</span>
<span class="nc" id="L255">            auxBuffer = ByteBuffer.allocate(auxSize);// cache moov in the memory</span>
        }

<span class="nc" id="L258">        moovSimulation = false;</span>
<span class="nc" id="L259">        writeOffset = 0;</span>

<span class="nc" id="L261">        final int ftyp_size = make_ftyp();</span>

        // reserve moov space in the output stream
        /*if (outStream.canSetLength()) {
            long length = writeOffset + auxSize;
            outStream.setLength(length);
            outSeek(length);
        } else {*/
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (auxSize &gt; 0) {</span>
<span class="nc" id="L270">            int length = auxSize;</span>
<span class="nc" id="L271">            byte[] buffer = new byte[8 * 1024];// 8 KiB</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">            while (length &gt; 0) {</span>
<span class="nc" id="L273">                int count = Math.min(length, buffer.length);</span>
<span class="nc" id="L274">                outWrite(buffer, 0, count);</span>
<span class="nc" id="L275">                length -= count;</span>
<span class="nc" id="L276">            }</span>
        }

<span class="nc bnc" id="L279" title="All 2 branches missed.">        if (auxBuffer == null) {</span>
<span class="nc" id="L280">            outSeek(ftyp_size);</span>
        }

        // tablesInfo contais row counts
        // and after returning from make_moov() will contain table offsets
<span class="nc" id="L285">        make_moov(defaultMediaTime, tablesInfo, is64);</span>

        // write tables: stts stsc
        // reset for ctts table: sampleCount sampleExtra
<span class="nc bnc" id="L289" title="All 2 branches missed.">        for (int i = 0; i &lt; readers.length; i++) {</span>
<span class="nc" id="L290">            writeEntryArray(tablesInfo[i].stts, 2, sampleCount[i], defaultSampleDuration[i]);</span>
<span class="nc" id="L291">            writeEntryArray(tablesInfo[i].stsc, tablesInfo[i].stsc_bEntries.length, tablesInfo[i].stsc_bEntries);</span>
<span class="nc" id="L292">            tablesInfo[i].stsc_bEntries = null;</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">            if (tablesInfo[i].ctts &gt; 0) {</span>
<span class="nc" id="L294">                sampleCount[i] = 1;// index is not base zero</span>
<span class="nc" id="L295">                sampleExtra[i] = -1;</span>
            }
        }

<span class="nc bnc" id="L299" title="All 2 branches missed.">        if (auxBuffer == null) {</span>
<span class="nc" id="L300">            outRestore();</span>
        }

<span class="nc" id="L303">        outWrite(make_mdat(totalSampleSize, is64));</span>

<span class="nc" id="L305">        int[] sampleIndex = new int[readers.length];</span>
<span class="nc" id="L306">        int[] sizes = new int[SAMPLES_PER_CHUNK];</span>
<span class="nc" id="L307">        int[] sync = new int[SAMPLES_PER_CHUNK];</span>

<span class="nc" id="L309">        int written = readers.length;</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">        while (written &gt; 0) {</span>
<span class="nc" id="L311">            written = 0;</span>

<span class="nc bnc" id="L313" title="All 2 branches missed.">            for (int i = 0; i &lt; readers.length; i++) {</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">                if (sampleIndex[i] &lt; 0) {</span>
<span class="nc" id="L315">                    continue;// track is done</span>
                }

<span class="nc" id="L318">                long chunkOffset = writeOffset;</span>
<span class="nc" id="L319">                int syncCount = 0;</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">                int limit = sampleIndex[i] == 0 ? SAMPLES_PER_CHUNK_INIT : SAMPLES_PER_CHUNK;</span>

<span class="nc" id="L322">                int j = 0;</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">                for (; j &lt; limit; j++) {</span>
<span class="nc" id="L324">                    Mp4DashSample sample = getNextSample(i);</span>

<span class="nc bnc" id="L326" title="All 2 branches missed.">                    if (sample == null) {</span>
<span class="nc bnc" id="L327" title="All 4 branches missed.">                        if (tablesInfo[i].ctts &gt; 0 &amp;&amp; sampleExtra[i] &gt;= 0) {</span>
<span class="nc" id="L328">                            writeEntryArray(tablesInfo[i].ctts, 1, sampleCount[i], sampleExtra[i]);// flush last entries</span>
                        }
<span class="nc" id="L330">                        sampleIndex[i] = -1;</span>
<span class="nc" id="L331">                        break;</span>
                    }

<span class="nc" id="L334">                    sampleIndex[i]++;</span>

<span class="nc bnc" id="L336" title="All 2 branches missed.">                    if (tablesInfo[i].ctts &gt; 0) {</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">                        if (sample.info.sampleCompositionTimeOffset == sampleExtra[i]) {</span>
<span class="nc" id="L338">                            sampleCount[i]++;</span>
                        } else {
<span class="nc bnc" id="L340" title="All 2 branches missed.">                            if (sampleExtra[i] &gt;= 0) {</span>
<span class="nc" id="L341">                                tablesInfo[i].ctts = writeEntryArray(tablesInfo[i].ctts, 2, sampleCount[i], sampleExtra[i]);</span>
<span class="nc" id="L342">                                outRestore();</span>
                            }
<span class="nc" id="L344">                            sampleCount[i] = 1;</span>
<span class="nc" id="L345">                            sampleExtra[i] = sample.info.sampleCompositionTimeOffset;</span>
                        }
                    }

<span class="nc bnc" id="L349" title="All 4 branches missed.">                    if (tablesInfo[i].stss &gt; 0 &amp;&amp; sample.info.isKeyframe) {</span>
<span class="nc" id="L350">                        sync[syncCount++] = sampleIndex[i];</span>
                    }

<span class="nc bnc" id="L353" title="All 2 branches missed.">                    if (tablesInfo[i].stsz &gt; 0) {</span>
<span class="nc" id="L354">                        sizes[j] = sample.data.length;</span>
                    }

<span class="nc" id="L357">                    outWrite(sample.data, 0, sample.data.length);</span>
                }

<span class="nc bnc" id="L360" title="All 2 branches missed.">                if (j &gt; 0) {</span>
<span class="nc" id="L361">                    written++;</span>

<span class="nc bnc" id="L363" title="All 2 branches missed.">                    if (tablesInfo[i].stsz &gt; 0) {</span>
<span class="nc" id="L364">                        tablesInfo[i].stsz = writeEntryArray(tablesInfo[i].stsz, j, sizes);</span>
                    }

<span class="nc bnc" id="L367" title="All 2 branches missed.">                    if (syncCount &gt; 0) {</span>
<span class="nc" id="L368">                        tablesInfo[i].stss = writeEntryArray(tablesInfo[i].stss, syncCount, sync);</span>
                    }

<span class="nc bnc" id="L371" title="All 2 branches missed.">                    if (is64) {</span>
<span class="nc" id="L372">                        tablesInfo[i].stco = writeEntry64(tablesInfo[i].stco, chunkOffset);</span>
                    } else {
<span class="nc" id="L374">                        tablesInfo[i].stco = writeEntryArray(tablesInfo[i].stco, 1, (int) chunkOffset);</span>
                    }

<span class="nc" id="L377">                    outRestore();</span>
                }
            }
        }

<span class="nc bnc" id="L382" title="All 2 branches missed.">        if (auxBuffer != null) {</span>
            // dump moov
<span class="nc" id="L384">            outSeek(ftyp_size);</span>
<span class="nc" id="L385">            outStream.write(auxBuffer.array(), 0, auxBuffer.capacity());</span>
<span class="nc" id="L386">            auxBuffer = null;</span>
        }
<span class="nc" id="L388">    }</span>

    private Mp4DashSample getNextSample(int track) throws IOException {
<span class="nc bnc" id="L391" title="All 2 branches missed.">        if (readersChunks[track] == null) {</span>
<span class="nc" id="L392">            readersChunks[track] = readers[track].getNextChunk(false);</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">            if (readersChunks[track] == null) {</span>
<span class="nc" id="L394">                return null;// EOF reached</span>
            }
        }

<span class="nc" id="L398">        Mp4DashSample sample = readersChunks[track].getNextSample();</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">        if (sample == null) {</span>
<span class="nc" id="L400">            readersChunks[track] = null;</span>
<span class="nc" id="L401">            return getNextSample(track);</span>
        } else {
<span class="nc" id="L403">            return sample;</span>
        }
    }

    // &lt;editor-fold defaultstate=&quot;expanded&quot; desc=&quot;Stbl handling&quot;&gt;
    private int writeEntry64(int offset, long value) throws IOException {
<span class="nc" id="L409">        outBackup();</span>

<span class="nc" id="L411">        auxSeek(offset);</span>
<span class="nc" id="L412">        auxWrite(ByteBuffer.allocate(8).putLong(value).array());</span>

<span class="nc" id="L414">        return offset + 8;</span>
    }

    private int writeEntryArray(int offset, int count, int... values) throws IOException {
<span class="nc" id="L418">        outBackup();</span>

<span class="nc" id="L420">        auxSeek(offset);</span>

<span class="nc" id="L422">        int size = count * 4;</span>
<span class="nc" id="L423">        ByteBuffer buffer = ByteBuffer.allocate(size);</span>

<span class="nc bnc" id="L425" title="All 2 branches missed.">        for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L426">            buffer.putInt(values[i]);</span>
        }

<span class="nc" id="L429">        auxWrite(buffer.array());</span>

<span class="nc" id="L431">        return offset + size;</span>
    }

    private void outBackup() {
<span class="nc bnc" id="L435" title="All 4 branches missed.">        if (auxBuffer == null &amp;&amp; lastWriteOffset &lt; 0) {</span>
<span class="nc" id="L436">            lastWriteOffset = writeOffset;</span>
        }
<span class="nc" id="L438">    }</span>

    /**
     * Restore to the previous position before the first call to writeEntry64()
     * or writeEntryArray() methods.
     */
    private void outRestore() throws IOException {
<span class="nc bnc" id="L445" title="All 2 branches missed.">        if (lastWriteOffset &gt; 0) {</span>
<span class="nc" id="L446">            outSeek(lastWriteOffset);</span>
<span class="nc" id="L447">            lastWriteOffset = -1;</span>
        }
<span class="nc" id="L449">    }</span>
    // &lt;/editor-fold&gt;

    // &lt;editor-fold defaultstate=&quot;expanded&quot; desc=&quot;Utils&quot;&gt;
    private void outWrite(byte[] buffer) throws IOException {
<span class="nc" id="L454">        outWrite(buffer, 0, buffer.length);</span>
<span class="nc" id="L455">    }</span>

    private void outWrite(byte[] buffer, int offset, int count) throws IOException {
<span class="nc" id="L458">        writeOffset += count;</span>
<span class="nc" id="L459">        outStream.write(buffer, offset, count);</span>
<span class="nc" id="L460">    }</span>

    private void outSeek(long offset) throws IOException {
<span class="nc bnc" id="L463" title="All 2 branches missed.">        if (outStream.canSeek()) {</span>
<span class="nc" id="L464">            outStream.seek(offset);</span>
<span class="nc" id="L465">            writeOffset = offset;</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">        } else if (outStream.canRewind()) {</span>
<span class="nc" id="L467">            outStream.rewind();</span>
<span class="nc" id="L468">            writeOffset = 0;</span>
<span class="nc" id="L469">            outSkip(offset);</span>
        } else {
<span class="nc" id="L471">            throw new IOException(&quot;cannot seek or rewind the output stream&quot;);</span>
        }
<span class="nc" id="L473">    }</span>

    private void outSkip(long amount) throws IOException {
<span class="nc" id="L476">        outStream.skip(amount);</span>
<span class="nc" id="L477">        writeOffset += amount;</span>
<span class="nc" id="L478">    }</span>

    private int lengthFor(int offset) throws IOException {
<span class="nc" id="L481">        int size = auxOffset() - offset;</span>

<span class="nc bnc" id="L483" title="All 2 branches missed.">        if (moovSimulation) {</span>
<span class="nc" id="L484">            return size;</span>
        }

<span class="nc" id="L487">        auxSeek(offset);</span>
<span class="nc" id="L488">        auxWrite(size);</span>
<span class="nc" id="L489">        auxSkip(size - 4);</span>

<span class="nc" id="L491">        return size;</span>
    }

    private int make(int type, int extra, int columns, int rows) throws IOException {
<span class="nc" id="L495">        final byte base = 16;</span>
<span class="nc" id="L496">        int size = columns * rows * 4;</span>
<span class="nc" id="L497">        int total = size + base;</span>
<span class="nc" id="L498">        int offset = auxOffset();</span>

<span class="nc bnc" id="L500" title="All 2 branches missed.">        if (extra &gt;= 0) {</span>
<span class="nc" id="L501">            total += 4;</span>
        }

<span class="nc" id="L504">        auxWrite(ByteBuffer.allocate(12)</span>
<span class="nc" id="L505">                .putInt(total)</span>
<span class="nc" id="L506">                .putInt(type)</span>
<span class="nc" id="L507">                .putInt(0x00)// default version &amp; flags</span>
<span class="nc" id="L508">                .array()</span>
        );

<span class="nc bnc" id="L511" title="All 2 branches missed.">        if (extra &gt;= 0) {</span>
            //size += 4;// commented for auxiliar buffer !!!
<span class="nc" id="L513">            offset += 4;</span>
<span class="nc" id="L514">            auxWrite(extra);</span>
        }

<span class="nc" id="L517">        auxWrite(rows);</span>
<span class="nc" id="L518">        auxSkip(size);</span>

<span class="nc" id="L520">        return offset + base;</span>
    }

    private void auxWrite(int value) throws IOException {
<span class="nc" id="L524">        auxWrite(ByteBuffer.allocate(4)</span>
<span class="nc" id="L525">                .putInt(value)</span>
<span class="nc" id="L526">                .array()</span>
        );
<span class="nc" id="L528">    }</span>

    private void auxWrite(byte[] buffer) throws IOException {
<span class="nc bnc" id="L531" title="All 2 branches missed.">        if (moovSimulation) {</span>
<span class="nc" id="L532">            writeOffset += buffer.length;</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">        } else if (auxBuffer == null) {</span>
<span class="nc" id="L534">            outWrite(buffer, 0, buffer.length);</span>
        } else {
<span class="nc" id="L536">            auxBuffer.put(buffer);</span>
        }
<span class="nc" id="L538">    }</span>

    private void auxSeek(int offset) throws IOException {
<span class="nc bnc" id="L541" title="All 2 branches missed.">        if (moovSimulation) {</span>
<span class="nc" id="L542">            writeOffset = offset;</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">        } else if (auxBuffer == null) {</span>
<span class="nc" id="L544">            outSeek(offset);</span>
        } else {
<span class="nc" id="L546">            auxBuffer.position(offset);</span>
        }
<span class="nc" id="L548">    }</span>

    private void auxSkip(int amount) throws IOException {
<span class="nc bnc" id="L551" title="All 2 branches missed.">        if (moovSimulation) {</span>
<span class="nc" id="L552">            writeOffset += amount;</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">        } else if (auxBuffer == null) {</span>
<span class="nc" id="L554">            outSkip(amount);</span>
        } else {
<span class="nc" id="L556">            auxBuffer.position(auxBuffer.position() + amount);</span>
        }
<span class="nc" id="L558">    }</span>

    private int auxOffset() {
<span class="nc bnc" id="L561" title="All 2 branches missed.">        return auxBuffer == null ? (int) writeOffset : auxBuffer.position();</span>
    }
    // &lt;/editor-fold&gt;

    // &lt;editor-fold defaultstate=&quot;expanded&quot; desc=&quot;Box makers&quot;&gt;
    private int make_ftyp() throws IOException {
<span class="nc" id="L567">        byte[] buffer = new byte[]{</span>
                0x00, 0x00, 0x00, 0x1C, 0x66, 0x74, 0x79, 0x70,// ftyp
                0x6D, 0x70, 0x34, 0x32,// mayor brand (mp42)
                0x00, 0x00, 0x02, 0x00,// default minor version (512)
                0x6D, 0x70, 0x34, 0x31, 0x69, 0x73, 0x6F, 0x6D, 0x69, 0x73, 0x6F, 0x32// compatible brands: mp41 isom iso2
        };

<span class="nc bnc" id="L574" title="All 2 branches missed.">        if (overrideMainBrand != 0)</span>
<span class="nc" id="L575">            ByteBuffer.wrap(buffer).putInt(8, overrideMainBrand);</span>

<span class="nc" id="L577">        outWrite(buffer);</span>

<span class="nc" id="L579">        return buffer.length;</span>
    }

    private byte[] make_mdat(long refSize, boolean is64) {
<span class="nc bnc" id="L583" title="All 2 branches missed.">        if (is64) {</span>
<span class="nc" id="L584">            refSize += 16;</span>
        } else {
<span class="nc" id="L586">            refSize += 8;</span>
        }

<span class="nc bnc" id="L589" title="All 4 branches missed.">        ByteBuffer buffer = ByteBuffer.allocate(is64 ? 16 : 8)</span>
<span class="nc" id="L590">                .putInt(is64 ? 0x01 : (int) refSize)</span>
<span class="nc" id="L591">                .putInt(0x6D646174);// mdat</span>

<span class="nc bnc" id="L593" title="All 2 branches missed.">        if (is64) {</span>
<span class="nc" id="L594">            buffer.putLong(refSize);</span>
        }

<span class="nc" id="L597">        return buffer.array();</span>
    }

    private void make_mvhd(long longestTrack) throws IOException {
<span class="nc" id="L601">        auxWrite(new byte[]{</span>
                0x00, 0x00, 0x00, 0x78, 0x6D, 0x76, 0x68, 0x64, 0x01, 0x00, 0x00, 0x00
        });
<span class="nc" id="L604">        auxWrite(ByteBuffer.allocate(28)</span>
<span class="nc" id="L605">                .putLong(time)</span>
<span class="nc" id="L606">                .putLong(time)</span>
<span class="nc" id="L607">                .putInt(DEFAULT_TIMESCALE)</span>
<span class="nc" id="L608">                .putLong(longestTrack)</span>
<span class="nc" id="L609">                .array()</span>
        );

<span class="nc" id="L612">        auxWrite(new byte[]{</span>
                0x00, 0x01, 0x00, 0x00, 0x01, 0x00,// default volume and rate
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,// reserved values
                // default matrix
                0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x40, 0x00, 0x00, 0x00
        });
<span class="nc" id="L620">        auxWrite(new byte[24]);// predefined</span>
<span class="nc" id="L621">        auxWrite(ByteBuffer.allocate(4)</span>
<span class="nc" id="L622">                .putInt(tracks.length + 1)</span>
<span class="nc" id="L623">                .array()</span>
        );
<span class="nc" id="L625">    }</span>

    private int make_moov(int[] defaultMediaTime, TablesInfo[] tablesInfo, boolean is64) throws RuntimeException, IOException {
<span class="nc" id="L628">        int start = auxOffset();</span>

<span class="nc" id="L630">        auxWrite(new byte[]{</span>
                0x00, 0x00, 0x00, 0x00, 0x6D, 0x6F, 0x6F, 0x76
        });

<span class="nc" id="L634">        long longestTrack = 0;</span>
<span class="nc" id="L635">        long[] durations = new long[tracks.length];</span>

<span class="nc bnc" id="L637" title="All 2 branches missed.">        for (int i = 0; i &lt; durations.length; i++) {</span>
<span class="nc" id="L638">            durations[i] = (long) Math.ceil(</span>
                    ((double) tracks[i].trak.tkhd.duration / tracks[i].trak.mdia.mdhd_timeScale) * DEFAULT_TIMESCALE
            );

<span class="nc bnc" id="L642" title="All 2 branches missed.">            if (durations[i] &gt; longestTrack) {</span>
<span class="nc" id="L643">                longestTrack = durations[i];</span>
            }
        }

<span class="nc" id="L647">        make_mvhd(longestTrack);</span>

<span class="nc bnc" id="L649" title="All 2 branches missed.">        for (int i = 0; i &lt; tracks.length; i++) {</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">            if (tracks[i].trak.tkhd.matrix.length != 36) {</span>
<span class="nc" id="L651">                throw new RuntimeException(&quot;bad track matrix length (expected 36) in track n°&quot; + i);</span>
            }
<span class="nc" id="L653">            make_trak(i, durations[i], defaultMediaTime[i], tablesInfo[i], is64);</span>
        }

        // udta/meta/ilst/©too
<span class="nc" id="L657">        auxWrite(new byte[]{</span>
                0x00, 0x00, 0x00, 0x5C, 0x75, 0x64, 0x74, 0x61, 0x00, 0x00, 0x00, 0x54, 0x6D, 0x65, 0x74, 0x61,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x68, 0x64, 0x6C, 0x72, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x6D, 0x64, 0x69, 0x72, 0x61, 0x70, 0x70, 0x6C, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x69, 0x6C, 0x73, 0x74, 0x00, 0x00, 0x00,
                0x1F, (byte) 0xA9, 0x74, 0x6F, 0x6F, 0x00, 0x00, 0x00, 0x17, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00,
                0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
                0x4E, 0x65, 0x77, 0x50, 0x69, 0x70, 0x65// &quot;NewPipe&quot; binary string
        });

<span class="nc" id="L667">        return lengthFor(start);</span>
    }

    private void make_trak(int index, long duration, int defaultMediaTime, TablesInfo tables, boolean is64) throws IOException {
<span class="nc" id="L671">        int start = auxOffset();</span>

<span class="nc" id="L673">        auxWrite(new byte[]{</span>
                0x00, 0x00, 0x00, 0x00, 0x74, 0x72, 0x61, 0x6B,// trak header
                0x00, 0x00, 0x00, 0x68, 0x74, 0x6B, 0x68, 0x64, 0x01, 0x00, 0x00, 0x03 // tkhd header
        });

<span class="nc" id="L678">        ByteBuffer buffer = ByteBuffer.allocate(48);</span>
<span class="nc" id="L679">        buffer.putLong(time);</span>
<span class="nc" id="L680">        buffer.putLong(time);</span>
<span class="nc" id="L681">        buffer.putInt(index + 1);</span>
<span class="nc" id="L682">        buffer.position(24);</span>
<span class="nc" id="L683">        buffer.putLong(duration);</span>
<span class="nc" id="L684">        buffer.position(40);</span>
<span class="nc" id="L685">        buffer.putShort(tracks[index].trak.tkhd.bLayer);</span>
<span class="nc" id="L686">        buffer.putShort(tracks[index].trak.tkhd.bAlternateGroup);</span>
<span class="nc" id="L687">        buffer.putShort(tracks[index].trak.tkhd.bVolume);</span>
<span class="nc" id="L688">        auxWrite(buffer.array());</span>

<span class="nc" id="L690">        auxWrite(tracks[index].trak.tkhd.matrix);</span>
<span class="nc" id="L691">        auxWrite(ByteBuffer.allocate(8)</span>
<span class="nc" id="L692">                .putInt(tracks[index].trak.tkhd.bWidth)</span>
<span class="nc" id="L693">                .putInt(tracks[index].trak.tkhd.bHeight)</span>
<span class="nc" id="L694">                .array()</span>
        );

<span class="nc" id="L697">        auxWrite(new byte[]{</span>
                0x00, 0x00, 0x00, 0x24, 0x65, 0x64, 0x74, 0x73,// edts header
                0x00, 0x00, 0x00, 0x1C, 0x65, 0x6C, 0x73, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01// elst header
        });

        int bMediaRate;
        int mediaTime;

<span class="nc bnc" id="L705" title="All 2 branches missed.">        if (tracks[index].trak.edst_elst == null) {</span>
            // is a audio track ¿is edst/elst opcional for audio tracks?
<span class="nc" id="L707">            mediaTime = 0x00;// ffmpeg set this value as zero, instead of defaultMediaTime</span>
<span class="nc" id="L708">            bMediaRate = 0x00010000;</span>
        } else {
<span class="nc" id="L710">            mediaTime = (int) tracks[index].trak.edst_elst.MediaTime;</span>
<span class="nc" id="L711">            bMediaRate = tracks[index].trak.edst_elst.bMediaRate;</span>
        }

<span class="nc" id="L714">        auxWrite(ByteBuffer</span>
<span class="nc" id="L715">                .allocate(12)</span>
<span class="nc" id="L716">                .putInt((int) duration)</span>
<span class="nc" id="L717">                .putInt(mediaTime)</span>
<span class="nc" id="L718">                .putInt(bMediaRate)</span>
<span class="nc" id="L719">                .array()</span>
        );

<span class="nc" id="L722">        make_mdia(tracks[index].trak.mdia, tables, is64);</span>

<span class="nc" id="L724">        lengthFor(start);</span>
<span class="nc" id="L725">    }</span>

    private void make_mdia(Mdia mdia, TablesInfo tablesInfo, boolean is64) throws IOException {

<span class="nc" id="L729">        int start_mdia = auxOffset();</span>
<span class="nc" id="L730">        auxWrite(new byte[]{0x00, 0x00, 0x00, 0x00, 0x6D, 0x64, 0x69, 0x61});// mdia</span>
<span class="nc" id="L731">        auxWrite(mdia.mdhd);</span>
<span class="nc" id="L732">        auxWrite(make_hdlr(mdia.hdlr));</span>

<span class="nc" id="L734">        int start_minf = auxOffset();</span>
<span class="nc" id="L735">        auxWrite(new byte[]{0x00, 0x00, 0x00, 0x00, 0x6D, 0x69, 0x6E, 0x66});// minf</span>
<span class="nc" id="L736">        auxWrite(mdia.minf.$mhd);</span>
<span class="nc" id="L737">        auxWrite(mdia.minf.dinf);</span>

<span class="nc" id="L739">        int start_stbl = auxOffset();</span>
<span class="nc" id="L740">        auxWrite(new byte[]{0x00, 0x00, 0x00, 0x00, 0x73, 0x74, 0x62, 0x6C});// stbl</span>
<span class="nc" id="L741">        auxWrite(mdia.minf.stbl_stsd);</span>

        //
        // In audio tracks the following tables is not required: ssts ctts
        // And stsz can be empty if has a default sample size
        //
<span class="nc bnc" id="L747" title="All 2 branches missed.">        if (moovSimulation) {</span>
<span class="nc" id="L748">            make(0x73747473, -1, 2, 1);</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">            if (tablesInfo.stss &gt; 0) {</span>
<span class="nc" id="L750">                make(0x73747373, -1, 1, tablesInfo.stss);</span>
            }
<span class="nc bnc" id="L752" title="All 2 branches missed.">            if (tablesInfo.ctts &gt; 0) {</span>
<span class="nc" id="L753">                make(0x63747473, -1, 2, tablesInfo.ctts);</span>
            }
<span class="nc" id="L755">            make(0x73747363, -1, 3, tablesInfo.stsc);</span>
<span class="nc" id="L756">            make(0x7374737A, tablesInfo.stsz_default, 1, tablesInfo.stsz);</span>
<span class="nc bnc" id="L757" title="All 4 branches missed.">            make(is64 ? 0x636F3634 : 0x7374636F, -1, is64 ? 2 : 1, tablesInfo.stco);</span>
        } else {
<span class="nc" id="L759">            tablesInfo.stts = make(0x73747473, -1, 2, 1);</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">            if (tablesInfo.stss &gt; 0) {</span>
<span class="nc" id="L761">                tablesInfo.stss = make(0x73747373, -1, 1, tablesInfo.stss);</span>
            }
<span class="nc bnc" id="L763" title="All 2 branches missed.">            if (tablesInfo.ctts &gt; 0) {</span>
<span class="nc" id="L764">                tablesInfo.ctts = make(0x63747473, -1, 2, tablesInfo.ctts);</span>
            }
<span class="nc" id="L766">            tablesInfo.stsc = make(0x73747363, -1, 3, tablesInfo.stsc);</span>
<span class="nc" id="L767">            tablesInfo.stsz = make(0x7374737A, tablesInfo.stsz_default, 1, tablesInfo.stsz);</span>
<span class="nc bnc" id="L768" title="All 4 branches missed.">            tablesInfo.stco = make(is64 ? 0x636F3634 : 0x7374636F, -1, is64 ? 2 : 1, tablesInfo.stco);</span>
        }

<span class="nc" id="L771">        lengthFor(start_stbl);</span>
<span class="nc" id="L772">        lengthFor(start_minf);</span>
<span class="nc" id="L773">        lengthFor(start_mdia);</span>
<span class="nc" id="L774">    }</span>

    private byte[] make_hdlr(Hdlr hdlr) {
<span class="nc" id="L777">        ByteBuffer buffer = ByteBuffer.wrap(new byte[]{</span>
                0x00, 0x00, 0x00, 0x77, 0x68, 0x64, 0x6C, 0x72,// hdlr
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                // binary string &quot;ISO Media file created in NewPipe (A libre lightweight streaming frontend for Android).&quot;
                0x49, 0x53, 0x4F, 0x20, 0x4D, 0x65, 0x64, 0x69, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x63,
                0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x4E, 0x65, 0x77, 0x50, 0x69, 0x70,
                0x65, 0x20, 0x28, 0x41, 0x20, 0x6C, 0x69, 0x62, 0x72, 0x65, 0x20, 0x6C, 0x69, 0x67, 0x68, 0x74,
                0x77, 0x65, 0x69, 0x67, 0x68, 0x74, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x69, 0x6E, 0x67,
                0x20, 0x66, 0x72, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x41, 0x6E,
                0x64, 0x72, 0x6F, 0x69, 0x64, 0x29, 0x2E
        });

<span class="nc" id="L790">        buffer.position(12);</span>
<span class="nc" id="L791">        buffer.putInt(hdlr.type);</span>
<span class="nc" id="L792">        buffer.putInt(hdlr.subType);</span>
<span class="nc" id="L793">        buffer.put(hdlr.bReserved);// always is a zero array</span>

<span class="nc" id="L795">        return buffer.array();</span>
    }
    //&lt;/editor-fold&gt;

<span class="nc" id="L799">    class TablesInfo {</span>

        public int stts;
        public int stsc;
        public int[] stsc_bEntries;
        public int ctts;
        public int stsz;
        public int stsz_default;
        public int stss;
        public int stco;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span>Generated by the Android Gradle plugin 3.2.0</div></body></html>